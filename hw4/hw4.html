        <!DOCTYPE html>

        <html>


        <head>
        <style>
            
        </style>
        <hr>
        <h1 style="text-align:center;font-family:verdana"> HW4 </h1>
            <hr>
            <div id="container" style="float:left;background-color:aqua;  width:60vw; height:40vw">
            
            </div>
            
            <div style="float:left; margin-right: 10px;background-color:bisque; width:32vw;">

                <audio id="collisionsound" style="display:none">
                    <source src="sounds/collision.wav" type='audio/wav'>
                    </audio>

                <br>
                Radius
                <input type=range min=8  max=20 step="2" value = 19 id='rad'> 

                <p>
                    <font id='soundtext'style="font-family:verdana;margin-left: 10px;" face="monospace" size='4' color='Black'>Sound</font>
                <input type="checkbox"style="margin-left: 10px;"id="sound" />
                </p>
                <font id='texts'style="font-family:verdana;margin-left: 10px;" face="monospace" size='4' color='Black'>No colison</font>
                <br><br><br><br>
                
                <button id="toggle" style="width:100%;height: 5vw;border:1px solid black;">

                    <center style="font-size:20px;font-family:verdana">Start/Pause</center>
                </button>

        
            </div>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/84/three.min.js"></script>
        <script src="https://threejs.org/examples/js/controls/OrbitControls.js">
        </script>
        <script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>


        <script>
        var motion=true;
        var r=10;
        var play=true;
        var disk;
        var ball;

        $('#sound').click ( function() {
        play = !play;
        if (play) { 
        $('#soundtext').text ('Sound')
        } else {
        $('#soundtext').text ('Mute')
        }
        });

        $('#rad').change ( function() {
        disk.geometry = new THREE.CircleGeometry($(this).val(), 32)
        r = $(this).val();

        });
        $('#toggle').click ( function() {
        motion = !motion;
        });
        class Ball {
        constructor (mesh, rad, color) {
            this.mesh = mesh;
            this.mesh.position.y=3
            this.radius = rad;
            this.pos = new THREE.Vector3()
            this.vel = new THREE.Vector3()
            this.force = new THREE.Vector3()
            //this.mesh.material.color =color ;
            scene.add (this.mesh);
            this.mesh.material.color.copy ( color.clone() );
        }
        
        update (dt) {
        // this.radius=r;
        if(!motion)dt=0;
        this.vel.add (this.force.clone().multiplyScalar (dt))
        this.pos.add (this.vel.clone().multiplyScalar(dt))
        if (this.pos.y <r-100) {
            console.log("down");
            this.pos.y =r-100;
            this.vel.y *= -0.8;
            if(play)
            collisionSound.play();
            // console.log(ball.pos.y);
            // console.log(-100+r);
            // console.log(r);
            }
            if(this.pos.y > 100-r){
            console.log("up");
            this.pos.y = 100-r;
            this.vel.y *= -0.8;
            if(play)
            collisionSound.play();
            }
            if(this.pos.x > 100-r){
            console.log("right");
            this.pos.x = 100-r;
            this.vel.x *= -0.8;
            if(play)
            collisionSound.play();
            
            }
        if(this.pos.x < r-100){
            console.log("left");
            this.pos.x =r-100;
            this.vel.x *= -0.8;
            if(play)
            collisionSound.play(); 
        }
            this.mesh.position.copy (this.pos)
        }
        
        }
    
        /*Check_Intersect(R, C, Rad)
        {
        var Rad2 = Rad * Rad;
        R.max.x -= C.x;  R.max.y -= C.y;
        R.min.x -= C.x;  R.min.y -= C.y;
        if (R.max.x < 0) 			
            if (R.max.y < 0) 		
                return ((R.max.x * R.max.x + R.max.y * R.max.y) < Rad2);
            else if (R.min.y > 0) 	
                return ((R.max.x * R.max.x + R.min.y * R.min.y) < Rad2);
            else 				
                return(ABS(R.max.x) < Rad);
        else if (R.min.x > 0)  
            if (R.max.y < 0) 
                return ((R.min.x * R.min.x + R.max.y * R.max.y) < Rad2);
            else if (R.min.y > 0)  
                return ((R.min.x * R.min.x + R.min.y * R.min.y) < Rad2);
            else 			
                return (R.min.x < Rad);
        else			
            if (R.max.y < 0) 	
                return (ABS(R.max.y) < Rad);
            else if (R.min.y > 0)  
                return (R.min.y < Rad);
            else 				
                return(true);
        }*/ 	
        /*class obstacle {
        constructor(mesh, width, height) {
            this.mesh = mesh;
            this.width = width;
            this.height = height;
            mesh.position.z = 1;
            this.max = new THREE.Vector3(mesh.position.x + width / 2, mesh.position.z + height / 2,0);
            this.min = new THREE.Vector3(mesh.position.x - width / 2,mesh.position.z - height / 2,0);
        // console.log(this.max)
            scene.add(this.mesh);
        }
        update() 
        {
        this.mesh.updateMatrixWorld() 
            this.max = new THREE.Vector3(this.mesh.position.x + this.width / 2, this.mesh.position.z + this.height / 2);
            this.min = new THREE.Vector3(this.mesh.position.x - this.width / 2,this.mesh.position.z - this.height / 2);
            //console.log(this.min)
            this.collidingCircle(ball);
            this.coordinateOrigin(ball)
        }
        collidingCircle(ball) {
        
            var a = this.max.clone().sub(ball.mesh.position.clone());
            // console.log(a)
        //console.log(ball.mesh.position)
            var b = this.min.clone().sub(ball.mesh.position.clone());
            
            if (a.x < 0) 
            {
            if (a.y < 0){ if (a.x * a.x + a.y * a.y <r * r)return 1; return 0;}
            else if (b.y > 0) {if (a.x * a.x + b.y * b.y < r * r) return 2;return 0;}
            else {if (Math.abs(a.x) <r) return 3;return 0;}
            } 
            else if (b.x > 0) 
            {  
            if (a.y < 0){ if (b.x * b.x + a.y * a.y < r * r)return 4;return 0;}
            else if (b.y > 0) {if (b.x * b.x + b.y * b.y< r * r)return 5; return 0;}
            else
            { if( b.x < r)return 6;return 0;}
            } 
            else 
            {
            if (a.y < 0){ if (Math.abs(a.y) <r)return 7;return 0;}
            else if (b.y > 0) { if(b.y < r)return 8;return 0;}
            else return 9;
            }
        }
        coordinateOrigin(ball)
        {
        var center = this.mesh.position.clone()
        var normalMat = new THREE.Matrix3().getNormalMatrix(this.mesh.matrixWorld);
        var xR = new THREE.Vector3(1, 0, 0)
        xR.applyMatrix3(normalMat).normalize()
        var yR = new THREE.Vector3(0, 1, 0)
        yR.applyMatrix3(normalMat).normalize()
        var cSubr = ball.mesh.position.clone().sub(center)
        var tmpC = new THREE.Vector3()
        tmpC.x = cSubr.clone().dot(xR)
        tmpC.y = cSubr.clone().dot(yR)
        
        var p1 = new THREE.Vector2(this.max.x, this.max.y).add(this.mesh.position)
        var p2 = new THREE.Vector2(this.min.x, this.max.y).add(this.mesh.position)
        var p3 = new THREE.Vector2(this.min.x, this.min.y).add(this.mesh.position)
        var p4 = new THREE.Vector2(this.max.x, this.min.y).add(this.mesh.position)
        var tmp 
        var res = this.collidingCircle(ball)
        // console.log(res)
        if(res == 1){
            tmp = p1.clone().sub(this.mesh.position).normalize()
            $('#normal').text(tmp.x.toFixed(1) + ", " + tmp.y.toFixed(1))
        }
        else if(res == 2){
            tmp = p4.clone().sub(this.mesh.position).normalize()
            $('#normal').text(tmp.x.toFixed(1) + ", " + tmp.y.toFixed(1))
        }
        else if(res == 3){
            tmp = p1.clone().add(p4).divideScalar(2).sub(this.mesh.position).normalize()
            $('#normal').text(tmp.x.toFixed(1) + ", " + tmp.y.toFixed(1))
        }
        else if(res == 4){
            tmp = p2.clone().sub(this.mesh.position).normalize()
            $('#normal').text(tmp.x.toFixed(1) + ", " + tmp.y.toFixed(1))
        }
        else if(res == 5){
            tmp = p3.clone().sub(this.mesh.position).normalize()
            $('#normal').text(tmp.x.toFixed(1) + ", " + tmp.y.toFixed(1))
        }
        else if(res == 6){
            tmp = p2.clone().add(p3).divideScalar(2).sub(this.mesh.position).normalize()
            $('#normal').text(tmp.x.toFixed(1) + ", " + tmp.y.toFixed(1))
        }
        else if(res == 7){
            tmp = p1.clone().add(p2).divideScalar(2).sub(this.mesh.position).normalize()
            $('#normal').text(tmp.x.toFixed(1) + ", " + tmp.y.toFixed(1))
        }
        else if(res == 8){
            tmp = p3.clone().add(p4).divideScalar(2).sub(this.mesh.position).normalize()
            $('#normal').text(tmp.x.toFixed(1) + ", " + tmp.y.toFixed(1))
        }
        return res
        }
        }*/
        ///////////////////////////////////////////////////////////////////////
        var camera, scene, renderer, light;
        var keyboard = new KeyboardState();
        var rectangle,angle=0;
        var boxs =[],box;
        var balls = [];
        var walls=[];
        var mouse = new THREE.Vector2();
        var raycaster;
        var pickables=[];
        var Rmaxx, Rmaxy, Rminx,Rminy;
        var cx,cy;
        var collisionSound;
        init();
        animate();
        
        function init() 
        {
        
        collisionSound = document.getElementById ('collisionsound');
        var ww = $("#container").innerWidth();
        var hh = $("#container").innerHeight();
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(ww, hh);
        renderer.setClearColor(0x999999);
        $("#container").append(renderer.domElement);
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.z = 250;
        var gridXZ = new THREE.GridHelper(200, 20, 'red', 'white');
        //scene.add(gridXZ);
        gridXZ.rotation.x=Math.PI/2
        /*let plane, wall
        wall = new THREE.Mesh ( new THREE.PlaneGeometry (5, 200), new THREE.MeshPhongMaterial({color:0x3c3c3c}) )
        scene.add (wall)
        wall.position.x =100;
        wall.position.z=1;
        wall = new THREE.Mesh ( new THREE.PlaneGeometry (5, 200), new THREE.MeshPhongMaterial({color:0x3c3c3c}) )
        scene.add (wall)
        wall.position.x =-100;
        wall.position.z=1;
        wall = new THREE.Mesh ( new THREE.PlaneGeometry (5, 200), new THREE.MeshPhongMaterial({color:0x3c3c3c}) )
        scene.add (wall)
        wall.rotation.z=Math.PI/2;
        wall.position.y =-100;
        wall.position.z=1;
        wall = new THREE.Mesh ( new THREE.PlaneGeometry (5, 200), new THREE.MeshPhongMaterial({color:0x3c3c3c}) )
        scene.add (wall)
        wall.rotation.z=Math.PI/2;
        wall.position.y =100;
        wall.position.z=1;*/


       let geometry = new THREE.Geometry();
       geometry.vertices.push(
        new THREE.Vector3(-100, -100, 0),
        new THREE.Vector3(100, -100, 0),
        new THREE.Vector3(100, 100, 0),
        new THREE.Vector3(-100, 100, 0),
        new THREE.Vector3(-100, -100, 0));

        let border = new THREE.Line(geometry, new THREE.LineBasicMaterial({
        color: 0x000000
    }));
        scene.add(border);

        var floor = new THREE.Mesh (new THREE.PlaneGeometry (300,300), new THREE.MeshBasicMaterial({  transparent: true,
            opacity: 0.5}))
        scene.add (floor)
        pickables = [floor];
        // let controls = new THREE.OrbitControls(camera, renderer.domElement);

        ///////////////////////////////////////////////////////////
        //r=10;
        disk = new THREE.Mesh (new THREE.CircleGeometry (r, r,20), new THREE.MeshBasicMaterial() )
        ball = new Ball (disk, r, new THREE.Color (0x00ffff))
        let ballx=Math.random()*100-50;
        let ballvx=Math.random()*60-30;
        let ballvy=Math.random()*50-25;
        ball.vel.set (ballvx,ballvy,0)
        ball.pos.set (ballx,ballx,3)
        raycaster = new THREE.Raycaster();

        window.addEventListener('mousedown', onDocumentMouseDown, false);
        box=new THREE.Mesh(new THREE.PlaneGeometry(80,80),new THREE.MeshBasicMaterial({color:0xffff00,opacity:0.6,transparent:true}))
        //rectangle=new obstacle(box,80,80);
        //rectangle.update();
        //boxs.push(rectangle);
        scene.add(box);
        window.addEventListener('resize', onWindowResize, false);
        }
        ///////////////////////////////////////small problem
        function onDocumentMouseDown(event) {
        var ww = $("#container").innerWidth();
        var hh = $("#container").innerHeight();
        // event.preventDefault();
        mouse.x = (event.clientX /ww) * 2-1 ;
        mouse.y = -(event.clientY / hh) * 2 +1;
        // find intersections
        raycaster.setFromCamera(mouse, camera);
        var intersects = raycaster.intersectObjects(pickables);
        if (intersects.length > 0) {
        // scene.add(box.mesh)
        box.position.copy(intersects[0].point);
        box.position.y=intersects[0].point.y+50;
        box.position.z=1;
        box
        console.log(intersects[0].point)
        }
        }

        
        function checkCollision () {
        // Call api 
        // Need to be replaced by a public ip address
        $.get( "http://127.0.0.1:1337/api?r="+ r + "&Rmaxx=" + Rmaxx +"&Rmaxy=" + Rmaxy +"&Rminx=" + Rminx + "&Rminy=" + Rminy + "&cx=" + cx + "&cy=" + cy, function( data ) {

        if(data && data.output){		
                result = parseInt(data.output, 10);			
                if(result == 1){
            ball.mesh.material.color = new THREE.Color(0xffd0ff); $('#texts').text ("Colision!");document.getElementById("texts").setAttribute("style", "color:red;font-family:verdana;margin-left: 10px;");
                }
                else{
            ball.mesh.material.color = new THREE.Color(0x00ffff); $('#texts').text ("No colision");document.getElementById("texts").setAttribute("style", "color:black;font-family:verdana;margin-left: 10px;");
                }
            }
            
        });
        }





        function onWindowResize() {
        var ww = $("#container").innerWidth();
        var hh = $("#container").innerHeight();
        camera.aspect = ww / hh;
        camera.updateProjectionMatrix();
        renderer.setSize(ww, hh);
        }
        function animate() {
            ball.update (0.1)
            cx = ball.mesh.position.x;
            cy = ball.mesh.position.y;
         
           
            //checkCollision();
            Rmaxx = 40 + box.position.x;
            Rmaxy = 40 + box.position.y;
            Rminx = box.position.x-40;
            Rminy = box.position.y-40;
            
            //rectangle.update();
        /*for (let i = 0; i < boxs.length; i++) {boxs[i].update();}
        for (let i = 0; i < boxs.length; i++) 
        {
        if(boxs[i].collidingCircle(ball)>=1) {ball.mesh.material.color = new THREE.Color(0xffd0ff); $('#texts').text ("Colision!");document.getElementById("texts").setAttribute("style", "color:red;font-family:verdana;margin-left: 10px;");}
        else {ball.mesh.material.color = new THREE.Color(0x00ffff); $('#texts').text ("No colision");document.getElementById("texts").setAttribute("style", "color:black;font-family:verdana;margin-left: 10px;");}
        }*/
        checkCollision();
        requestAnimationFrame(animate);
        render();
        }


        function render() {
        renderer.render(scene, camera);
        }

        </script>
        </body>

        </html>